<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>GNU Radio 2.x: omnithread.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.3 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>omnithread.h</h1><a href="omnithread_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">// -*- Mode: C++; -*-</span>
00002 <span class="comment">//                              Package : omnithread</span>
00003 <span class="comment">// omnithread.h                 Created : 7/94 tjr</span>
00004 <span class="comment">//</span>
00005 <span class="comment">//    Copyright (C) 1994,1995,1996, 1997 Olivetti &amp; Oracle Research Laboratory</span>
00006 <span class="comment">//</span>
00007 <span class="comment">//    This file is part of the omnithread library</span>
00008 <span class="comment">//</span>
00009 <span class="comment">//    The omnithread library is free software; you can redistribute it and/or</span>
00010 <span class="comment">//    modify it under the terms of the GNU Library General Public</span>
00011 <span class="comment">//    License as published by the Free Software Foundation; either</span>
00012 <span class="comment">//    version 2 of the License, or (at your option) any later version.</span>
00013 <span class="comment">//</span>
00014 <span class="comment">//    This library is distributed in the hope that it will be useful,</span>
00015 <span class="comment">//    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00016 <span class="comment">//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00017 <span class="comment">//    Library General Public License for more details.</span>
00018 <span class="comment">//</span>
00019 <span class="comment">//    You should have received a copy of the GNU Library General Public</span>
00020 <span class="comment">//    License along with this library; if not, write to the Free</span>
00021 <span class="comment">//    Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  </span>
00022 <span class="comment">//    02111-1307, USA</span>
00023 <span class="comment">//</span>
00024 
00025 <span class="comment">//</span>
00026 <span class="comment">// Interface to OMNI thread abstraction.</span>
00027 <span class="comment">//</span>
00028 <span class="comment">// This file declares classes for threads and synchronisation objects</span>
00029 <span class="comment">// (mutexes, condition variables and counting semaphores).</span>
00030 <span class="comment">//</span>
00031 <span class="comment">// Wherever a seemingly arbitrary choice has had to be made as to the interface</span>
00032 <span class="comment">// provided, the intention here has been to be as POSIX-like as possible.  This</span>
00033 <span class="comment">// is why there is no semaphore timed wait, for example.</span>
00034 <span class="comment">//</span>
00035 
00036 <span class="preprocessor">#ifndef __omnithread_h_</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#define __omnithread_h_</span>
00038 <span class="preprocessor"></span>
00039 <span class="preprocessor">#ifndef NULL</span>
<a name="l00040"></a><a class="code" href="omnithread_8h.html#a0">00040</a> <span class="preprocessor"></span><span class="preprocessor">#define NULL 0</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00042 <span class="preprocessor"></span>
00043 <span class="keyword">class </span><a class="code" href="classomni__mutex.html">omni_mutex</a>;
00044 <span class="keyword">class </span><a class="code" href="classomni__condition.html">omni_condition</a>;
00045 <span class="keyword">class </span><a class="code" href="classomni__semaphore.html">omni_semaphore</a>;
00046 <span class="keyword">class </span><a class="code" href="classomni__thread.html">omni_thread</a>;
00047 
00048 <span class="comment">//</span>
00049 <span class="comment">// OMNI_THREAD_EXPOSE can be defined as public or protected to expose the</span>
00050 <span class="comment">// implementation class - this may be useful for debugging.  Hopefully this</span>
00051 <span class="comment">// won't change the underlying structure which the compiler generates so that</span>
00052 <span class="comment">// this can work without recompiling the library.</span>
00053 <span class="comment">//</span>
00054 
00055 <span class="preprocessor">#ifndef OMNI_THREAD_EXPOSE</span>
<a name="l00056"></a><a class="code" href="omnithread_8h.html#a1">00056</a> <span class="preprocessor"></span><span class="preprocessor">#define OMNI_THREAD_EXPOSE private</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00058 <span class="preprocessor"></span>
00059 <span class="comment">//</span>
00060 <span class="comment">// Include implementation-specific header file.</span>
00061 <span class="comment">//</span>
00062 <span class="comment">// This must define 4 CPP macros of the form OMNI_x_IMPLEMENTATION for mutex,</span>
00063 <span class="comment">// condition variable, semaphore and thread.  Each should define any</span>
00064 <span class="comment">// implementation-specific members of the corresponding classes.</span>
00065 <span class="comment">//</span>
00066 
00067 
00068 <span class="comment">//</span>
00069 <span class="comment">// For now, we assume they've always got a Posix Threads implementation.</span>
00070 <span class="comment">// If not, it'll take some configure hacking to sort it out, along with</span>
00071 <span class="comment">// the relevant libraries to link with, etc.</span>
00072 <span class="comment">//</span>
00073 
00074 <span class="preprocessor">#if !defined(OMNITHREAD_POSIX) &amp;&amp; !defined(OMNITHREAD_NT) &amp;&amp; defined HAVE_CONFIG_H</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#include &lt;config.h&gt;</span>
00076 <span class="preprocessor">#endif</span>
00077 <span class="preprocessor"></span>
00078 <span class="preprocessor">#if defined(OMNITHREAD_POSIX)</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="ot__posix_8h.html">ot_posix.h</a>&gt;</span>
00080 
00081 <span class="preprocessor">#elif defined(OMNITHREAD_NT)</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="ot__nt_8h.html">ot_nt.h</a>&gt;</span>
00083 
00084 <span class="preprocessor">#ifdef _MSC_VER</span>
00085 <span class="preprocessor"></span>
00086 <span class="comment">// Using MSVC++ to compile. If compiling library as a DLL,</span>
00087 <span class="comment">// define _OMNITHREAD_DLL. If compiling as a statuc library, define</span>
00088 <span class="comment">// _WINSTATIC</span>
00089 <span class="comment">// If compiling an application that is to be statically linked to omnithread,</span>
00090 <span class="comment">// define _WINSTATIC (if the application is  to be dynamically linked, </span>
00091 <span class="comment">// there is no need to define any of these macros).</span>
00092 
00093 <span class="preprocessor">#if defined (_OMNITHREAD_DLL) &amp;&amp; defined(_WINSTATIC)</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#error "Both _OMNITHREAD_DLL and _WINSTATIC are defined."</span>
00095 <span class="preprocessor"></span><span class="preprocessor">#elif defined(_OMNITHREAD_DLL)</span>
00096 <span class="preprocessor"></span><span class="preprocessor">#define _OMNITHREAD_NTDLL_ __declspec(dllexport)</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#elif !defined(_WINSTATIC)</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#define _OMNITHREAD_NTDLL_ __declspec(dllimport)</span>
00099 <span class="preprocessor"></span><span class="preprocessor">#elif defined(_WINSTATIC)</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#define _OMNITHREAD_NTDLL_</span>
00101 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00102 <span class="preprocessor"></span> <span class="comment">// _OMNITHREAD_DLL &amp;&amp; _WINSTATIC</span>
00103 
00104 <span class="preprocessor">#else</span>
00105 <span class="preprocessor"></span>
00106 <span class="comment">// Not using MSVC++ to compile</span>
00107 <span class="preprocessor">#define _OMNITHREAD_NTDLL_</span>
00108 <span class="preprocessor"></span>
00109 <span class="preprocessor">#endif</span>
00110 <span class="preprocessor"></span> <span class="comment">// _MSC_VER</span>
00111  
00112 <span class="preprocessor">#elif defined(__vxWorks__)</span>
00113 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="ot__VxThread_8h.html">ot_VxThread.h</a>&gt;</span>
00114 
00115 <span class="preprocessor">#elif defined(__sunos__)</span>
00116 <span class="preprocessor"></span><span class="preprocessor">#if __OSVERSION__ != 5</span>
00117 <span class="preprocessor"></span><span class="comment">// XXX Workaround for SUN C++ compiler (seen on 4.2) Template.DB code</span>
00118 <span class="comment">//     regeneration bug. See omniORB2/CORBA_sysdep.h for details.</span>
00119 <span class="preprocessor">#if !defined(__SUNPRO_CC) || __OSVERSION__ != '5'</span>
00120 <span class="preprocessor"></span><span class="preprocessor">#error "Only SunOS 5.x or later is supported."</span>
00121 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00122 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00123 <span class="preprocessor"></span><span class="preprocessor">#ifdef UseSolarisThreads</span>
00124 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="ot__solaris_8h.html">ot_solaris.h</a>&gt;</span>
00125 <span class="preprocessor">#else</span>
00126 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="ot__posix_8h.html">ot_posix.h</a>&gt;</span>
00127 <span class="preprocessor">#endif</span>
00128 <span class="preprocessor"></span>
00129 <span class="preprocessor">#elif defined(__rtems__)</span>
00130 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="ot__posix_8h.html">ot_posix.h</a>&gt;</span>
00131 <span class="preprocessor">#include &lt;sched.h&gt;</span>
00132 
00133 <span class="preprocessor">#elif defined(__macos__)</span>
00134 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="ot__posix_8h.html">ot_posix.h</a>&gt;</span>
00135 <span class="preprocessor">#include &lt;sched.h&gt;</span>
00136 
00137 <span class="preprocessor">#else</span>
00138 <span class="preprocessor"></span><span class="preprocessor">#error "No implementation header file"</span>
00139 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00140 <span class="preprocessor"></span>
00141 
00142 <span class="preprocessor">#if !defined(__WIN32__)</span>
<a name="l00143"></a><a class="code" href="omnithread_8h.html#a2">00143</a> <span class="preprocessor"></span><span class="preprocessor">#define _OMNITHREAD_NTDLL_</span>
00144 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00145 <span class="preprocessor"></span>
00146 <span class="preprocessor">#if (!defined(OMNI_MUTEX_IMPLEMENTATION)        || \</span>
00147 <span class="preprocessor">     !defined(OMNI_MUTEX_LOCK_IMPLEMENTATION)   || \</span>
00148 <span class="preprocessor">     !defined(OMNI_MUTEX_UNLOCK_IMPLEMENTATION) || \</span>
00149 <span class="preprocessor">     !defined(OMNI_CONDITION_IMPLEMENTATION)    || \</span>
00150 <span class="preprocessor">     !defined(OMNI_SEMAPHORE_IMPLEMENTATION)    || \</span>
00151 <span class="preprocessor">     !defined(OMNI_THREAD_IMPLEMENTATION))</span>
00152 <span class="preprocessor"></span><span class="preprocessor">#error "Implementation header file incomplete"</span>
00153 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00154 <span class="preprocessor"></span>
00155 
00156 <span class="comment">//</span>
00157 <span class="comment">// This exception is thrown in the event of a fatal error.</span>
00158 <span class="comment">//</span>
00159 
<a name="l00160"></a><a class="code" href="classomni__thread__fatal.html">00160</a> <span class="keyword">class </span><a class="code" href="omnithread_8h.html#a2">_OMNITHREAD_NTDLL_</a> omni_thread_fatal {
00161 <span class="keyword">public</span>:
<a name="l00162"></a><a class="code" href="classomni__thread__fatal.html#o0">00162</a>     <span class="keywordtype">int</span> error;
<a name="l00163"></a><a class="code" href="classomni__thread__fatal.html#a0">00163</a>     omni_thread_fatal(<span class="keywordtype">int</span> e = 0) : error(e) {}
00164 };
00165 
00166 
00167 <span class="comment">//</span>
00168 <span class="comment">// This exception is thrown when an operation is invoked with invalid</span>
00169 <span class="comment">// arguments.</span>
00170 <span class="comment">//</span>
00171 
<a name="l00172"></a><a class="code" href="classomni__thread__invalid.html">00172</a> <span class="keyword">class </span><a class="code" href="omnithread_8h.html#a2">_OMNITHREAD_NTDLL_</a> omni_thread_invalid {};
00173 
00174 
00176 <span class="comment">//</span>
00177 <span class="comment">// Mutex</span>
00178 <span class="comment">//</span>
00180 <span class="comment"></span>
<a name="l00181"></a><a class="code" href="classomni__mutex.html">00181</a> <span class="keyword">class </span><a class="code" href="omnithread_8h.html#a2">_OMNITHREAD_NTDLL_</a> omni_mutex {
00182 
00183 <span class="keyword">public</span>:
00184     omni_mutex(<span class="keywordtype">void</span>);
00185     ~omni_mutex(<span class="keywordtype">void</span>);
00186 
<a name="l00187"></a><a class="code" href="classomni__mutex.html#a2">00187</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> lock(<span class="keywordtype">void</span>)    { <a class="code" href="ot__nt_8h.html#a3">OMNI_MUTEX_LOCK_IMPLEMENTATION</a>   }
<a name="l00188"></a><a class="code" href="classomni__mutex.html#a3">00188</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> unlock(<span class="keywordtype">void</span>)  { <a class="code" href="ot__nt_8h.html#a4">OMNI_MUTEX_UNLOCK_IMPLEMENTATION</a> }
<a name="l00189"></a><a class="code" href="classomni__mutex.html#a4">00189</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> acquire(<span class="keywordtype">void</span>) { lock(); }
<a name="l00190"></a><a class="code" href="classomni__mutex.html#a5">00190</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> release(<span class="keywordtype">void</span>) { unlock(); }
00191         <span class="comment">// the names lock and unlock are preferred over acquire and release</span>
00192         <span class="comment">// since we are attempting to be as POSIX-like as possible.</span>
00193 
<a name="l00194"></a><a class="code" href="classomni__mutex.html#n0">00194</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classomni__condition.html">omni_condition</a>;
00195 
00196 <span class="keyword">private</span>:
00197     <span class="comment">// dummy copy constructor and operator= to prevent copying</span>
00198     omni_mutex(<span class="keyword">const</span> omni_mutex&amp;);
00199     omni_mutex&amp; operator=(<span class="keyword">const</span> omni_mutex&amp;);
00200 
00201 <a class="code" href="omnithread_8h.html#a1">OMNI_THREAD_EXPOSE</a>:
00202     <a class="code" href="ot__mach_8h.html#a0">OMNI_MUTEX_IMPLEMENTATION</a>
00203 };
00204 
00205 <span class="comment">//</span>
00206 <span class="comment">// As an alternative to:</span>
00207 <span class="comment">// {</span>
00208 <span class="comment">//   mutex.lock();</span>
00209 <span class="comment">//   .....</span>
00210 <span class="comment">//   mutex.unlock();</span>
00211 <span class="comment">// }</span>
00212 <span class="comment">//</span>
00213 <span class="comment">// you can use a single instance of the omni_mutex_lock class:</span>
00214 <span class="comment">//</span>
00215 <span class="comment">// {</span>
00216 <span class="comment">//   omni_mutex_lock l(mutex);</span>
00217 <span class="comment">//   ....</span>
00218 <span class="comment">// }</span>
00219 <span class="comment">//</span>
00220 <span class="comment">// This has the advantage that mutex.unlock() will be called automatically</span>
00221 <span class="comment">// when an exception is thrown.</span>
00222 <span class="comment">//</span>
00223 
<a name="l00224"></a><a class="code" href="classomni__mutex__lock.html">00224</a> <span class="keyword">class </span><a class="code" href="omnithread_8h.html#a2">_OMNITHREAD_NTDLL_</a> omni_mutex_lock {
00225     omni_mutex&amp; mutex;
00226 <span class="keyword">public</span>:
<a name="l00227"></a><a class="code" href="classomni__mutex__lock.html#a0">00227</a>     omni_mutex_lock(omni_mutex&amp; m) : mutex(m) { mutex.lock(); }
<a name="l00228"></a><a class="code" href="classomni__mutex__lock.html#a1">00228</a>     ~omni_mutex_lock(<span class="keywordtype">void</span>) { mutex.unlock(); }
00229 <span class="keyword">private</span>:
00230     <span class="comment">// dummy copy constructor and operator= to prevent copying</span>
00231     omni_mutex_lock(<span class="keyword">const</span> omni_mutex_lock&amp;);
00232     omni_mutex_lock&amp; operator=(<span class="keyword">const</span> omni_mutex_lock&amp;);
00233 };
00234 
00235 
00237 <span class="comment">//</span>
00238 <span class="comment">// Condition variable</span>
00239 <span class="comment">//</span>
00241 <span class="comment"></span>
<a name="l00242"></a><a class="code" href="classomni__condition.html">00242</a> <span class="keyword">class </span><a class="code" href="omnithread_8h.html#a2">_OMNITHREAD_NTDLL_</a> omni_condition {
00243 
00244     omni_mutex* mutex;
00245 
00246 <span class="keyword">public</span>:
00247     omni_condition(omni_mutex* m);
00248         <span class="comment">// constructor must be given a pointer to an existing mutex. The</span>
00249         <span class="comment">// condition variable is then linked to the mutex, so that there is an</span>
00250         <span class="comment">// implicit unlock and lock around wait() and timed_wait().</span>
00251 
00252     ~omni_condition(<span class="keywordtype">void</span>);
00253 
00254     <span class="keywordtype">void</span> wait(<span class="keywordtype">void</span>);
00255         <span class="comment">// wait for the condition variable to be signalled.  The mutex is</span>
00256         <span class="comment">// implicitly released before waiting and locked again after waking up.</span>
00257         <span class="comment">// If wait() is called by multiple threads, a signal may wake up more</span>
00258         <span class="comment">// than one thread.  See POSIX threads documentation for details.</span>
00259 
00260     <span class="keywordtype">int</span> timedwait(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> secs, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nanosecs = 0);
00261         <span class="comment">// timedwait() is given an absolute time to wait until.  To wait for a</span>
00262         <span class="comment">// relative time from now, use omni_thread::get_time. See POSIX threads</span>
00263         <span class="comment">// documentation for why absolute times are better than relative.</span>
00264         <span class="comment">// Returns 1 (true) if successfully signalled, 0 (false) if time</span>
00265         <span class="comment">// expired.</span>
00266 
00267     <span class="keywordtype">void</span> signal(<span class="keywordtype">void</span>);
00268         <span class="comment">// if one or more threads have called wait(), signal wakes up at least</span>
00269         <span class="comment">// one of them, possibly more.  See POSIX threads documentation for</span>
00270         <span class="comment">// details.</span>
00271 
00272     <span class="keywordtype">void</span> broadcast(<span class="keywordtype">void</span>);
00273         <span class="comment">// broadcast is like signal but wakes all threads which have called</span>
00274         <span class="comment">// wait().</span>
00275 
00276 <span class="keyword">private</span>:
00277     <span class="comment">// dummy copy constructor and operator= to prevent copying</span>
00278     omni_condition(<span class="keyword">const</span> omni_condition&amp;);
00279     omni_condition&amp; operator=(<span class="keyword">const</span> omni_condition&amp;);
00280 
00281 <a class="code" href="omnithread_8h.html#a1">OMNI_THREAD_EXPOSE</a>:
00282     <a class="code" href="ot__mach_8h.html#a1">OMNI_CONDITION_IMPLEMENTATION</a>
00283 };
00284 
00285 
00287 <span class="comment">//</span>
00288 <span class="comment">// Counting semaphore</span>
00289 <span class="comment">//</span>
00291 <span class="comment"></span>
<a name="l00292"></a><a class="code" href="classomni__semaphore.html">00292</a> <span class="keyword">class </span><a class="code" href="omnithread_8h.html#a2">_OMNITHREAD_NTDLL_</a> omni_semaphore {
00293 
00294 <span class="keyword">public</span>:
00295     omni_semaphore(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial = 1);
00296     ~omni_semaphore(<span class="keywordtype">void</span>);
00297 
00298     <span class="keywordtype">void</span> wait(<span class="keywordtype">void</span>);
00299         <span class="comment">// if semaphore value is &gt; 0 then decrement it and carry on. If it's</span>
00300         <span class="comment">// already 0 then block.</span>
00301 
00302     <span class="keywordtype">int</span> trywait(<span class="keywordtype">void</span>);
00303         <span class="comment">// if semaphore value is &gt; 0 then decrement it and return 1 (true).</span>
00304         <span class="comment">// If it's already 0 then return 0 (false).</span>
00305 
00306     <span class="keywordtype">void</span> post(<span class="keywordtype">void</span>);
00307         <span class="comment">// if any threads are blocked in wait(), wake one of them up. Otherwise</span>
00308         <span class="comment">// increment the value of the semaphore.</span>
00309 
00310 <span class="keyword">private</span>:
00311     <span class="comment">// dummy copy constructor and operator= to prevent copying</span>
00312     omni_semaphore(<span class="keyword">const</span> omni_semaphore&amp;);
00313     omni_semaphore&amp; operator=(<span class="keyword">const</span> omni_semaphore&amp;);
00314 
00315 <a class="code" href="omnithread_8h.html#a1">OMNI_THREAD_EXPOSE</a>:
00316     <a class="code" href="ot__mach_8h.html#a2">OMNI_SEMAPHORE_IMPLEMENTATION</a>
00317 };
00318 
00319 <span class="comment">//</span>
00320 <span class="comment">// A helper class for semaphores, similar to omni_mutex_lock above.</span>
00321 <span class="comment">//</span>
00322 
<a name="l00323"></a><a class="code" href="classomni__semaphore__lock.html">00323</a> <span class="keyword">class </span><a class="code" href="omnithread_8h.html#a2">_OMNITHREAD_NTDLL_</a> omni_semaphore_lock {
00324     omni_semaphore&amp; sem;
00325 <span class="keyword">public</span>:
<a name="l00326"></a><a class="code" href="classomni__semaphore__lock.html#a0">00326</a>     omni_semaphore_lock(omni_semaphore&amp; s) : sem(s) { sem.wait(); }
<a name="l00327"></a><a class="code" href="classomni__semaphore__lock.html#a1">00327</a>     ~omni_semaphore_lock(<span class="keywordtype">void</span>) { sem.post(); }
00328 <span class="keyword">private</span>:
00329     <span class="comment">// dummy copy constructor and operator= to prevent copying</span>
00330     omni_semaphore_lock(<span class="keyword">const</span> omni_semaphore_lock&amp;);
00331     omni_semaphore_lock&amp; operator=(<span class="keyword">const</span> omni_semaphore_lock&amp;);
00332 };
00333 
00334 
00336 <span class="comment">//</span>
00337 <span class="comment">// Thread</span>
00338 <span class="comment">//</span>
00340 <span class="comment"></span>
<a name="l00341"></a><a class="code" href="classomni__thread.html">00341</a> <span class="keyword">class </span><a class="code" href="omnithread_8h.html#a2">_OMNITHREAD_NTDLL_</a> omni_thread {
00342 
00343 <span class="keyword">public</span>:
00344 
<a name="l00345"></a><a class="code" href="classomni__thread.html#w7">00345</a>     <span class="keyword">enum</span> priority_t {
00346         PRIORITY_LOW,
00347         PRIORITY_NORMAL,
00348         PRIORITY_HIGH
00349     };
00350 
<a name="l00351"></a><a class="code" href="classomni__thread.html#w8">00351</a>     <span class="keyword">enum</span> state_t {
00352         STATE_NEW,              <span class="comment">// thread object exists but thread hasn't</span>
00353                                 <span class="comment">// started yet.</span>
00354         STATE_RUNNING,          <span class="comment">// thread is running.</span>
00355         STATE_TERMINATED        <span class="comment">// thread has terminated but storage has not</span>
00356                                 <span class="comment">// been reclaimed (i.e. waiting to be joined).</span>
00357     };
00358 
00359     <span class="comment">//</span>
00360     <span class="comment">// Constructors set up the thread object but the thread won't start until</span>
00361     <span class="comment">// start() is called. The create method can be used to construct and start</span>
00362     <span class="comment">// a thread in a single call.</span>
00363     <span class="comment">//</span>
00364 
00365     omni_thread(<span class="keywordtype">void</span> (*fn)(<span class="keywordtype">void</span>*), <span class="keywordtype">void</span>* arg = NULL,
00366                 priority_t pri = PRIORITY_NORMAL);
00367     omni_thread(<span class="keywordtype">void</span>* (*fn)(<span class="keywordtype">void</span>*), <span class="keywordtype">void</span>* arg = NULL,
00368                 priority_t pri = PRIORITY_NORMAL);
00369         <span class="comment">// these constructors create a thread which will run the given function</span>
00370         <span class="comment">// when start() is called.  The thread will be detached if given a</span>
00371         <span class="comment">// function with void return type, undetached if given a function</span>
00372         <span class="comment">// returning void*. If a thread is detached, storage for the thread is</span>
00373         <span class="comment">// reclaimed automatically on termination. Only an undetached thread</span>
00374         <span class="comment">// can be joined.</span>
00375 
00376     <span class="keywordtype">void</span> start(<span class="keywordtype">void</span>);
00377         <span class="comment">// start() causes a thread created with one of the constructors to</span>
00378         <span class="comment">// start executing the appropriate function.</span>
00379 
00380 <span class="keyword">protected</span>:
00381 
00382     omni_thread(<span class="keywordtype">void</span>* arg = NULL, priority_t pri = PRIORITY_NORMAL);
00383         <span class="comment">// this constructor is used in a derived class.  The thread will</span>
00384         <span class="comment">// execute the run() or run_undetached() member functions depending on</span>
00385         <span class="comment">// whether start() or start_undetached() is called respectively.</span>
00386 
00387     <span class="keywordtype">void</span> start_undetached(<span class="keywordtype">void</span>);
00388         <span class="comment">// can be used with the above constructor in a derived class to cause</span>
00389         <span class="comment">// the thread to be undetached.  In this case the thread executes the</span>
00390         <span class="comment">// run_undetached member function.</span>
00391 
00392     <span class="keyword">virtual</span> ~omni_thread(<span class="keywordtype">void</span>);
00393         <span class="comment">// destructor cannot be called by user (except via a derived class).</span>
00394         <span class="comment">// Use exit() or cancel() instead. This also means a thread object must</span>
00395         <span class="comment">// be allocated with new - it cannot be statically or automatically</span>
00396         <span class="comment">// allocated. The destructor of a class that inherits from omni_thread</span>
00397         <span class="comment">// shouldn't be public either (otherwise the thread object can be</span>
00398         <span class="comment">// destroyed while the underlying thread is still running).</span>
00399 
00400 <span class="keyword">public</span>:
00401 
00402     <span class="keywordtype">void</span> join(<span class="keywordtype">void</span>**);
00403         <span class="comment">// join causes the calling thread to wait for another's completion,</span>
00404         <span class="comment">// putting the return value in the variable of type void* whose address</span>
00405         <span class="comment">// is given (unless passed a null pointer). Only undetached threads</span>
00406         <span class="comment">// may be joined. Storage for the thread will be reclaimed.</span>
00407 
00408     <span class="keywordtype">void</span> set_priority(priority_t);
00409         <span class="comment">// set the priority of the thread.</span>
00410 
00411     <span class="keyword">static</span> omni_thread* create(<span class="keywordtype">void</span> (*fn)(<span class="keywordtype">void</span>*), <span class="keywordtype">void</span>* arg = NULL,
00412                                priority_t pri = PRIORITY_NORMAL);
00413     <span class="keyword">static</span> omni_thread* create(<span class="keywordtype">void</span>* (*fn)(<span class="keywordtype">void</span>*), <span class="keywordtype">void</span>* arg = NULL,
00414                                priority_t pri = PRIORITY_NORMAL);
00415         <span class="comment">// create spawns a new thread executing the given function with the</span>
00416         <span class="comment">// given argument at the given priority. Returns a pointer to the</span>
00417         <span class="comment">// thread object. It simply constructs a new thread object then calls</span>
00418         <span class="comment">// start.</span>
00419 
00420     <span class="keyword">static</span> <span class="keywordtype">void</span> exit(<span class="keywordtype">void</span>* return_value = NULL);
00421         <span class="comment">// causes the calling thread to terminate.</span>
00422 
00423     <span class="keyword">static</span> omni_thread* self(<span class="keywordtype">void</span>);
00424         <span class="comment">// returns the calling thread's omni_thread object.  If the</span>
00425         <span class="comment">// calling thread is not the main thread and is not created</span>
00426         <span class="comment">// using this library, returns 0. (But see create_dummy()</span>
00427         <span class="comment">// below.)</span>
00428 
00429     <span class="keyword">static</span> <span class="keywordtype">void</span> yield(<span class="keywordtype">void</span>);
00430         <span class="comment">// allows another thread to run.</span>
00431 
00432     <span class="keyword">static</span> <span class="keywordtype">void</span> sleep(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> secs, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nanosecs = 0);
00433         <span class="comment">// sleeps for the given time.</span>
00434 
00435     <span class="keyword">static</span> <span class="keywordtype">void</span> get_time(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* abs_sec, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* abs_nsec,
00436                          <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> rel_sec = 0, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> rel_nsec=0);
00437         <span class="comment">// calculates an absolute time in seconds and nanoseconds, suitable for</span>
00438         <span class="comment">// use in timed_waits on condition variables, which is the current time</span>
00439         <span class="comment">// plus the given relative offset.</span>
00440 
00441 
00442     <span class="keyword">static</span> <span class="keywordtype">void</span> stacksize(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sz);
00443     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> stacksize();
00444         <span class="comment">// Use this value as the stack size when spawning a new thread.</span>
00445         <span class="comment">// The default value (0) means that the thread library default is</span>
00446         <span class="comment">// to be used.</span>
00447 
00448 
00449     <span class="comment">// Per-thread data</span>
00450     <span class="comment">//</span>
00451     <span class="comment">// These functions allow you to attach additional data to an</span>
00452     <span class="comment">// omni_thread. First allocate a key for yourself with</span>
00453     <span class="comment">// allocate_key(). Then you can store any object whose class is</span>
00454     <span class="comment">// derived from value_t. Any values still stored in the</span>
00455     <span class="comment">// omni_thread when the thread exits are deleted.</span>
00456     <span class="comment">//</span>
00457     <span class="comment">// These functions are NOT thread safe, so you should be very</span>
00458     <span class="comment">// careful about setting/getting data in a different thread to the</span>
00459     <span class="comment">// current thread.</span>
00460 
<a name="l00461"></a><a class="code" href="classomni__thread.html#w0">00461</a>     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> key_t;
00462     <span class="keyword">static</span> key_t allocate_key();
00463 
<a name="l00464"></a><a class="code" href="classomni__thread_1_1value__t.html">00464</a>     <span class="keyword">class </span><a class="code" href="classomni__thread_1_1value__t.html">value_t</a> {
00465     <span class="keyword">public</span>:
<a name="l00466"></a><a class="code" href="classomni__thread_1_1value__t.html#a0">00466</a>       <span class="keyword">virtual</span> ~<a class="code" href="classomni__thread_1_1value__t.html">value_t</a>() {}
00467     };
00468 
00469     value_t* set_value(key_t k, value_t* v);
00470         <span class="comment">// Sets a value associated with the given key. The key must</span>
00471         <span class="comment">// have been allocated with allocate_key(). If a value has</span>
00472         <span class="comment">// already been set with the specified key, the old value_t</span>
00473         <span class="comment">// object is deleted and replaced. Returns the value which was</span>
00474         <span class="comment">// set, or zero if the key is invalid.</span>
00475 
00476     value_t* get_value(key_t k);
00477         <span class="comment">// Returns the value associated with the key. If the key is</span>
00478         <span class="comment">// invalid, or there is no value for the key, returns zero.</span>
00479 
00480     value_t* remove_value(key_t k);
00481         <span class="comment">// Removes the value associated with the key and returns it.</span>
00482         <span class="comment">// If the key is invalid, or there is no value for the key,</span>
00483         <span class="comment">// returns zero.</span>
00484 
00485 
00486     <span class="comment">// Dummy omni_thread</span>
00487     <span class="comment">//</span>
00488     <span class="comment">// Sometimes, an application finds itself with threads created</span>
00489     <span class="comment">// outside of omnithread which must interact with omnithread</span>
00490     <span class="comment">// features such as the per-thread data. In this situation,</span>
00491     <span class="comment">// omni_thread::self() would normally return 0. These functions</span>
00492     <span class="comment">// allow the application to create a suitable dummy omni_thread</span>
00493     <span class="comment">// object.</span>
00494 
00495     <span class="keyword">static</span> omni_thread* create_dummy(<span class="keywordtype">void</span>);
00496         <span class="comment">// creates a dummy omni_thread for the calling thread. Future</span>
00497         <span class="comment">// calls to self() will return the dummy omni_thread. Throws</span>
00498         <span class="comment">// omni_thread_invalid if this thread already has an</span>
00499         <span class="comment">// associated omni_thread (real or dummy).</span>
00500 
00501     <span class="keyword">static</span> <span class="keywordtype">void</span> release_dummy();
00502         <span class="comment">// release the dummy omni_thread for this thread. This</span>
00503         <span class="comment">// function MUST be called before the thread exits. Throws</span>
00504         <span class="comment">// omni_thread_invalid if the calling thread does not have a</span>
00505         <span class="comment">// dummy omni_thread.</span>
00506 
00507     <span class="comment">// class ensure_self should be created on the stack. If created in</span>
00508     <span class="comment">// a thread without an associated omni_thread, it creates a dummy</span>
00509     <span class="comment">// thread which is released when the ensure_self object is deleted.</span>
00510 
<a name="l00511"></a><a class="code" href="classomni__thread_1_1ensure__self.html">00511</a>     <span class="keyword">class </span><a class="code" href="classomni__thread_1_1ensure__self.html">ensure_self</a> {
00512     <span class="keyword">public</span>:
<a name="l00513"></a><a class="code" href="classomni__thread_1_1ensure__self.html#a0">00513</a>       <span class="keyword">inline</span> <a class="code" href="classomni__thread_1_1ensure__self.html">ensure_self</a>() : _dummy(0)
00514       {
00515         _self = <a class="code" href="classomni__thread.html#e3">omni_thread::self</a>();
00516         <span class="keywordflow">if</span> (!_self) {
00517           _dummy = 1;
00518           _self  = <a class="code" href="classomni__thread.html#e10">omni_thread::create_dummy</a>();
00519         }
00520       }
<a name="l00521"></a><a class="code" href="classomni__thread_1_1ensure__self.html#a1">00521</a>       <span class="keyword">inline</span> ~<a class="code" href="classomni__thread_1_1ensure__self.html">ensure_self</a>()
00522       {
00523         <span class="keywordflow">if</span> (_dummy)
00524           <a class="code" href="classomni__thread.html#e11">omni_thread::release_dummy</a>();
00525       }
<a name="l00526"></a><a class="code" href="classomni__thread_1_1ensure__self.html#a2">00526</a>       <span class="keyword">inline</span> omni_thread* self() { <span class="keywordflow">return</span> _self; }
00527     <span class="keyword">private</span>:
00528       omni_thread* _self;
00529       <span class="keywordtype">int</span>          _dummy;
00530     };
00531 
00532 
00533 <span class="keyword">private</span>:
00534 
00535     <span class="keyword">virtual</span> <span class="keywordtype">void</span> run(<span class="keywordtype">void</span>* <span class="comment">/*arg*/</span>) {}
00536     <span class="keyword">virtual</span> <span class="keywordtype">void</span>* run_undetached(<span class="keywordtype">void</span>* <span class="comment">/*arg*/</span>) { <span class="keywordflow">return</span> <a class="code" href="omnithread_8h.html#a0">NULL</a>; }
00537         <span class="comment">// can be overridden in a derived class.  When constructed using the</span>
00538         <span class="comment">// the constructor omni_thread(void*, priority_t), these functions are</span>
00539         <span class="comment">// called by start() and start_undetached() respectively.</span>
00540 
00541     <span class="keywordtype">void</span> common_constructor(<span class="keywordtype">void</span>* arg, priority_t pri, <span class="keywordtype">int</span> det);
00542         <span class="comment">// implements the common parts of the constructors.</span>
00543 
00544     omni_mutex mutex;
00545         <span class="comment">// used to protect any members which can change after construction,</span>
00546         <span class="comment">// i.e. the following 2 members.</span>
00547 
00548     state_t _state;
00549     priority_t _priority;
00550 
00551     <span class="keyword">static</span> omni_mutex* next_id_mutex;
00552     <span class="keyword">static</span> <span class="keywordtype">int</span> next_id;
00553     <span class="keywordtype">int</span> _id;
00554 
00555     <a class="code" href="gnuradio__swig__python_8cc.html#a255">void</a> (*fn_void)(<span class="keywordtype">void</span>*);
00556     <span class="keywordtype">void</span>* (*fn_ret)(<span class="keywordtype">void</span>*);
00557     <span class="keywordtype">void</span>* thread_arg;
00558     <span class="keywordtype">int</span> detached;
00559     <span class="keywordtype">int</span> _dummy;
00560     value_t**     _values;
00561     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> _value_alloc;
00562 
00563     omni_thread(<span class="keyword">const</span> omni_thread&amp;);
00564     omni_thread&amp; operator=(<span class="keyword">const</span> omni_thread&amp;);
00565     <span class="comment">// Not implemented</span>
00566 
00567 <span class="keyword">public</span>:
00568 
<a name="l00569"></a><a class="code" href="classomni__thread.html#a8">00569</a>     priority_t priority(<span class="keywordtype">void</span>) {
00570 
00571         <span class="comment">// return this thread's priority.</span>
00572 
00573         omni_mutex_lock l(mutex);
00574         <span class="keywordflow">return</span> _priority;
00575     }
00576 
<a name="l00577"></a><a class="code" href="classomni__thread.html#a9">00577</a>     state_t state(<span class="keywordtype">void</span>) {
00578 
00579         <span class="comment">// return thread state (invalid, new, running or terminated).</span>
00580 
00581         omni_mutex_lock l(mutex);
00582         <span class="keywordflow">return</span> _state;
00583     }
00584 
<a name="l00585"></a><a class="code" href="classomni__thread.html#a10">00585</a>     <span class="keywordtype">int</span> id(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> _id; }
00586         <span class="comment">// return unique thread id within the current process.</span>
00587 
00588 
00589     <span class="comment">// This class plus the instance of it declared below allows us to execute</span>
00590     <span class="comment">// some initialisation code before main() is called.</span>
00591 
<a name="l00592"></a><a class="code" href="classomni__thread_1_1init__t.html">00592</a>     <span class="keyword">class </span><a class="code" href="omnithread_8h.html#a2">_OMNITHREAD_NTDLL_</a> init_t {
00593     <span class="keyword">public</span>:
00594         init_t(<span class="keywordtype">void</span>);
00595         ~init_t(<span class="keywordtype">void</span>);
00596     };
00597 
<a name="l00598"></a><a class="code" href="classomni__thread.html#n0">00598</a>     <span class="keyword">friend</span> <span class="keyword">class </span>init_t;
<a name="l00599"></a><a class="code" href="classomni__thread.html#n1">00599</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classomni__thread__dummy.html">omni_thread_dummy</a>;
00600 
00601 <a class="code" href="omnithread_8h.html#a1">OMNI_THREAD_EXPOSE</a>:
00602     <a class="code" href="ot__mach_8h.html#a3">OMNI_THREAD_IMPLEMENTATION</a>
00603 };
00604 
00605 <span class="preprocessor">#ifndef __rtems__</span>
00606 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="classomni__thread_1_1init__t.html">omni_thread::init_t</a> omni_thread_init;
00607 <span class="preprocessor">#else</span>
00608 <span class="preprocessor"></span><span class="comment">// RTEMS calls global Ctor/Dtor in a context that is not</span>
00609 <span class="comment">// a posix thread. Calls to functions to pthread_self() in</span>
00610 <span class="comment">// that context returns NULL. </span>
00611 <span class="comment">// So, for RTEMS we will make the thread initialization at the</span>
00612 <span class="comment">// beginning of the Init task that has a posix context.</span>
00613 <span class="preprocessor">#endif</span>
00614 <span class="preprocessor"></span>
00615 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jul 21 09:35:17 2004 for GNU Radio 2.x by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.3 </small></address>
</body>
</html>
